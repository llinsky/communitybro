# Generated by binpac_quickstart
%extern{
	#include <algorithm>
%}
%header{
	std::string build_data_string(uint8 type_byte, bytestring telnet_data);
	bool search_data(std::string* data_str, std::string target_str);
	void generate_event(int event_type);
%}

refine flow TELNET_Flow += {
	function proc_telnet_message(msg: TELNET_PDU): bool
	%{
		/* TODO: linemode backup if negotiations are missed */
		connection()->set_orig(${msg.is_orig});

		vector<TELNET_field*>* fields = ${msg.telnet_fields};
		vector<TELNET_field*>::const_iterator fields_ptr;

		for (fields_ptr = fields->begin(); fields_ptr != fields->end(); ++fields_ptr) {
			switch((*fields_ptr)->type_byte())	
			{
				/* 0xFF indicates subcommands or connection negotiations */
				case COMMAND:
				{
					switch ((*fields_ptr)->nondata_packet()->command())
					{
						case SUBOPTION_BEGIN:
							break;
						case DO:
						{
							if ((*fields_ptr)->nondata_packet()->negotiation()->negcmd() == LINEMODE)
								connection()->set_linemode(TELNET_COOKED);
						} break;
						case DONT:
						{
							if ((*fields_ptr)->nondata_packet()->negotiation()->negcmd() == LINEMODE)
								connection()->set_linemode(TELNET_RAW);
						} break;
						case WILL:
						{
							if ((*fields_ptr)->nondata_packet()->negotiation()->negcmd() == LINEMODE)
								connection()->set_linemode(TELNET_COOKED);
						} break;
						case WONT:
						{
							if ((*fields_ptr)->nondata_packet()->negotiation()->negcmd() == LINEMODE)
								connection()->set_linemode(TELNET_RAW);
						} break;
						default:
						{
							//std::cout << "Defaulted: nondata_packet()->command()" << endl;
						} break;
					}
				} break;

				/* Packets without leading 0xFF contain only data */
				default:
				{	
					std::string data_str = build_data_string((*fields_ptr)->type_byte(), (*fields_ptr)->data_packet()->telnet_data());
					switch (connection()->get_state())
					{	
						case NO_EXPECT:
						{	
							if (connection()->get_check_login()) {
								if (search_data(&data_str, "login incorrect")) {
									bad_login(true);
								} 
								else if (connection()->get_login_checks() == MAX_LOGIN_CHECKS) {
									bad_login(false);
								} else {
									connection()->set_login_checks(connection()->get_login_checks() + 1);
								}
							}

							/* Check for prompts while not expecting credentials */
							if (search_data(&data_str, "login: ")) {
								connection()->set_state(EXPECT_USERNAME);	
							} 
							else if (search_data(&data_str, "password:")) {
								connection()->set_state(EXPECT_PASSWORD);
							} 
							/* Note: "Login incorrect" and "login: " can appear in same packet */
							else if (search_data(&data_str, "last login:")) {
								bad_login(false);
							}

							fetch_data(data_str, connection()->get_linemode(), NO_EXPECT);

						} break;

						case LOGIN_SUCCESS:
						{
							fetch_data(data_str, connection()->get_linemode(), NO_EXPECT);
						} break;

						case EXPECT_USERNAME:
						{
							fetch_data(data_str, connection()->get_linemode(), EXPECT_USERNAME);
						} break;
				
						case EXPECT_PASSWORD:
						{
							fetch_data(data_str, connection()->get_linemode(), EXPECT_PASSWORD);
							connection()->set_check_login(true);
						} break;

						default:
						{
							//std::cout << "Defaulted: connection()->get_state()" << endl;
						} break;
					}
				} break;
			}
		}
		return true;
	%}

	function fetch_data(data: string, linemode: int, event_type: int): bool
	%{
		switch (linemode)
		{
			case TELNET_RAW:
			{	
				/* Server data is sent whole, unless it's echoed data, which we discard  */
				if (!connection()->get_orig() && data.size() > 2) {
					if (data.find(BACKSPACE) != std::string::npos) {
						std::string tmp = connection()->get_data();
						if (tmp.size() > 1) {
							tmp.erase(tmp.end()-2, tmp.end());
							connection()->set_data(tmp);
						}
					} else {
						connection()->set_data(data);
						generate_event(event_type);
					}
				} 
				/* '\r\0' is the final character of all raw telnet data */
				else if (data.find("\r\0") != std::string::npos) {
					generate_event(event_type);
				} 
				/* Still building data char by char */
				else if (connection()->get_orig()) {
					connection()->set_data(connection()->get_data() += data);
				}
				/* Else garbage server echoed characters */
			} break;
			
			case TELNET_COOKED:
			{
				connection()->set_data(data);
				generate_event(event_type);
			} break;

			default:
			{
				//std::cout << "Defaulted: generate_event(event_type)" << endl;
			} break;
		}
		return true;
	%}

	function generate_event(event_type: int): bool
	%{

		/* Strip escape characters */
		std::string tmp_str = connection()->get_data();
		
		tmp_str.erase(std::remove_if(tmp_str.begin(), 
			tmp_str.end(),
			[](unsigned char x){return !std::isprint(x);}),
			tmp_str.end());

		switch (event_type)
		{
			case EXPECT_USERNAME:
			{
				BifEvent::generate_telnet_username_event(connection()->bro_analyzer(),
					connection()->bro_analyzer()->Conn(),
					new StringVal(tmp_str));
				connection()->clear_creds();
				connection()->set_last_username(tmp_str);
				connection()->set_state(NO_EXPECT);
			} break;

			case EXPECT_PASSWORD:
			{
				BifEvent::generate_telnet_password_event(connection()->bro_analyzer(),
					connection()->bro_analyzer()->Conn(),
					new StringVal(tmp_str));
				connection()->set_last_password(tmp_str);
				connection()->set_state(NO_EXPECT);
			} break;

			case NO_EXPECT:
			{
				if (!tmp_str.empty()) {
					if (connection()->get_orig())
						BifEvent::generate_telnet_sent_event(connection()->bro_analyzer(),
							connection()->bro_analyzer()->Conn(),
							new StringVal(tmp_str));
					else 
						BifEvent::generate_telnet_received_event(connection()->bro_analyzer(),
							connection()->bro_analyzer()->Conn(),
							new StringVal(tmp_str));
				}
			} break;

			case LOGIN_SUCCESS:
			{
				BifEvent::generate_telnet_login_event(connection()->bro_analyzer(),
					connection()->bro_analyzer()->Conn(),
					new StringVal(connection()->get_last_username()),
					new StringVal(connection()->get_last_password()),
					true);
				connection()->set_state(LOGIN_SUCCESS);
			} break;

			case LOGIN_FAIL:
			{
				BifEvent::generate_telnet_login_event(connection()->bro_analyzer(),
					connection()->bro_analyzer()->Conn(),
					new StringVal(connection()->get_last_username()),
					new StringVal(connection()->get_last_password()),
					false);
					connection()->set_state(NO_EXPECT);
			} break;

			default:
			{
				//std::cout << "Defaulted: generate_event(event_type)" << endl;
				connection()->set_state(NO_EXPECT);
			} break;
		}
		connection()->clear_data();
		return true;
	%}

	# Make necessary state changes on successful/failed login 
	function bad_login(result: bool): bool
	%{
		if (result) {
			connection()->set_session(false);
			connection()->set_check_login(false);
			connection()->set_login_checks(0);
			generate_event(LOGIN_FAIL);
			connection()->clear_creds();
		} else {
				connection()->set_session(true);
				connection()->set_check_login(false);
				connection()->set_login_checks(0);
				generate_event(LOGIN_SUCCESS);
				connection()->set_state(LOGIN_SUCCESS);
		}
		return true;
	%}

};

%code{ /* Functions in here do not require access to 'connection' object */

/* Build std::string from (uint8) type_byte and (bytestring) data */
std::string build_data_string(uint8 type_byte, bytestring telnet_data)
{
	std::string data_str;
	data_str += type_byte;
	data_str.append(std::string(telnet_data.data(), 
			telnet_data.data() + telnet_data.length()));
	data_str.erase(std::remove(data_str.begin(), data_str.end(), '\0'), data_str.end());
	return data_str;
}

bool search_data(std::string* data_str, std::string target_str)
{
	/* Want to preserve case of original string while performing case insensitive searches */
	std::string tmp = *data_str;
	std::transform(tmp.begin(), tmp.end(), tmp.begin(), ::tolower);
	if (tmp.size() < target_str.size()) {
		return false;
	} else if (target_str == "login: ") {
		/* To avoid catching "Last login: " */
		if (tmp.substr(tmp.size() - target_str.size()).find(target_str) != std::string::npos)
			return true;
	} else if (tmp.find(target_str) != std::string::npos) {
		return true;
	}
	return false;
}

%}

refine typeattr TELNET_PDU += &let {
	proc: bool = $context.flow.proc_telnet_message(this);
};
